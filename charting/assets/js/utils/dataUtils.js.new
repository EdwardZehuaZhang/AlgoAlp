// Data parsing and processing utilities

import { TimeUtils } from './timeUtils.js';

export class DataUtils {
    // Static values for market hours to ensure consistency
    static MARKET_OPEN_HOUR = 9;
    static MARKET_OPEN_MINUTE = 30;
    static MARKET_CLOSE_HOUR = 16;
    static MARKET_CLOSE_MINUTE = 0;
    
    /**
     * Parse CSV text to data array
     * @param {string} text - Raw CSV text
     * @returns {Array} Array of parsed data objects
     */
    static parseCSV(text) {
        const lines = text.trim().split('\n');
        const headers = lines[0].split(',').map(header => header.trim().replace(/\r/g, '').replace(/\n/g, ''));
        
        // Find column indices
        const timeIndex = headers.indexOf('time');
        const openIndex = headers.indexOf('open');
        const highIndex = headers.indexOf('high');
        const lowIndex = headers.indexOf('low');
        const closeIndex = headers.indexOf('close');
        let volumeIndex = headers.indexOf('volume');
        
        // Flexible volume matching
        if (volumeIndex === -1) {
            volumeIndex = headers.findIndex(header => header.toLowerCase().includes('volume'));
        }
        
        console.log('CSV Headers:', headers);
        console.log('Volume column index:', volumeIndex);
        
        const data = [];
        for (let i = 1; i < lines.length; i++) {
            const values = lines[i].split(',');
            
            // Parse time value
            let timeValue = values[timeIndex];
            
            if (!isNaN(timeValue)) {
                // Numeric timestamp (Unix timestamp)
                timeValue = parseFloat(timeValue);
            } else {
                // String timestamp, preserve NYC market time by creating a UTC date
                // Format: "2023-06-12 09:30:00" -> keep as NYC time
                const [datePart, timePart] = timeValue.split(' ');
                const [year, month, day] = datePart.split('-').map(Number);
                const [hour, minute, second] = timePart.split(':').map(Number);
                
                // Create a timestamp that will display correctly as NYC time
                // Use UTC date to prevent browser's timezone conversion
                const utcDate = Date.UTC(year, month - 1, day, hour, minute, second);
                timeValue = Math.floor(utcDate / 1000);
            }
            
            // Parse volume
            let volumeValue = 0;
            if (volumeIndex >= 0 && values[volumeIndex]) {
                volumeValue = parseFloat(values[volumeIndex]);
            }
            
            data.push({
                time: timeValue,
                open: parseFloat(values[openIndex]),
                high: parseFloat(values[highIndex]),
                low: parseFloat(values[lowIndex]),
                close: parseFloat(values[closeIndex]),
                volume: volumeValue
            });
        }
        
        return data;
    }
    
    /**
     * Filter data to market hours only (9:30 AM - 4:00 PM Eastern Time)
     * @param {Array} data - Bar data with time field
     * @returns {Array} Filtered data
     */
    static filterMarketHours(data) {
        const openMinutes = 9 * 60 + 30;  // 9:30 AM
        const closeMinutes = 16 * 60;     // 4:00 PM
        
        return data.filter(item => {
            const date = new Date(item.time * 1000);
            const hours = date.getUTCHours();
            const minutes = date.getUTCMinutes();
            const totalMinutes = hours * 60 + minutes;
            
            // Adjust for timezone (Eastern Time)
            const isDST = TimeUtils.isDaylightSavingTime(date);
            const etOffset = isDST ? 4 : 5; // EDT or EST offset from UTC in hours
            
            // Convert to Eastern Time
            let etTotalMinutes = totalMinutes - (etOffset * 60);
            if (etTotalMinutes < 0) {
                etTotalMinutes += 24 * 60; // Wrap around for previous day
            }
            
            return etTotalMinutes >= openMinutes && etTotalMinutes <= closeMinutes;
        });
    }
    
    /**
     * Transform Polygon API data to chart format
     * @param {Array} apiData - Raw API data from Polygon
     * @returns {Array} Transformed data for charts
     */
    static transformPolygonData(apiData) {
        // Sort the data by timestamp first to ensure correct ordering
        const sortedData = [...apiData].sort((a, b) => a.t - b.t);
        
        // Group data by day
        const groupedByDay = {};
        
        for (const item of sortedData) {
            const date = new Date(item.t);
            const dateStr = `${date.getUTCFullYear()}-${String(date.getUTCMonth() + 1).padStart(2, '0')}-${String(date.getUTCDate()).padStart(2, '0')}`;
            
            if (!groupedByDay[dateStr]) {
                groupedByDay[dateStr] = [];
            }
            
            groupedByDay[dateStr].push(item);
        }
        
        // For each day, remap timestamps to start at 9:30 AM
        const result = [];
        
        for (const dateStr in groupedByDay) {
            const dayData = groupedByDay[dateStr];
            // Sort by timestamp to ensure we're in the right order
            dayData.sort((a, b) => a.t - b.t);
            
            // Extract just the date portion from the first item
            const firstItem = dayData[0];
            const date = new Date(firstItem.t);
            const year = date.getUTCFullYear();
            const month = date.getUTCMonth();
            const day = date.getUTCDate();
            
            // Process each candle for the day
            for (let i = 0; i < dayData.length; i++) {
                const item = dayData[i];
                
                // Calculate minutes from the start of trading (in 5-minute increments)
                const minutesFromOpen = i * 5;
                
                // Set time to start at market open (9:30 AM) + offset
                const marketOpenHour = DataUtils.MARKET_OPEN_HOUR;
                const marketOpenMinute = DataUtils.MARKET_OPEN_MINUTE;
                
                // Calculate new hour and minute
                let newMinute = marketOpenMinute + minutesFromOpen;
                let newHour = marketOpenHour;
                
                // Adjust hours if minutes overflow
                while (newMinute >= 60) {
                    newHour++;
                    newMinute -= 60;
                }
                
                // Create a timestamp for the start of market hours + the offset
                const marketTimeUTC = Date.UTC(year, month, day, newHour, newMinute, 0);
                const timestamp = Math.floor(marketTimeUTC / 1000);
                
                // Log for debugging (first few items)
                if (i < 5) {
                    console.log('FIXED Polygon Time:');
                    console.log(`  Day ${dateStr}, Candle #${i+1}`);
                    console.log(`  Original:`, new Date(item.t).toUTCString());
                    console.log(`  Remapped:`, new Date(marketTimeUTC).toUTCString());
                    console.log(`  Display Time: ${newHour}:${newMinute.toString().padStart(2, '0')}`);
                    console.log(`  Final timestamp:`, timestamp);
                }
                
                // Extract price and volume data
                const barData = {
                    time: timestamp,
                    open: item.o,
                    high: item.h,
                    low: item.l,
                    close: item.c,
                    volume: item.v
                };
                
                result.push(barData);
            }
        }
        
        return result;
    }
}
